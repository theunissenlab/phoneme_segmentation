---
title: "Fig3_Sup3"
author: "Frederic Theunissen & Lily Xue Gong"
date: "5/27/2022"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## R Loading up the depencies

```{r libraries}
library(knitr)  # for making tables
library(nnet)   # for multinom()
library(rstatix) # for multinom_test()
library(mclogit)

library(dplyr)  # for filter()

library(ggplot2) # for the boxplot()
library(ggpubr)

library(kableExtra) ## save kable

```

## Setting up the data frames

Here we load the data and generate 3 new data frames to separate wholeBrain, Broca and Temporal Cortex. Note that we set the diphone as the base level.


```{r dataload, echo=FALSE}

# Read the data
data_roi_phns <- read.csv("../stats_data/df_wta_phns.csv" )

# Clean up
data_roi_phns <- na.omit(data_roi_phns)
data_roi_phns <- subset(data_roi_phns, select = -X)

# Split into 3 different data frames
dataLC <- filter(data_roi_phns, rois != "wholeBrain" & rois != "Broca" & models !="semantic")
attach(dataLC)
rois <-factor(rois)
levels(rois) <- c("ACunique", "STG", "STS", "LTCunique")
models <-factor(models)
levels(models) <- c("diphone", "single", "triphone", ordered=TRUE)
detach(dataLC)

dataWB <- filter(data_roi_phns, rois == "wholeBrain"  & models !="semantic")
dataWB <- subset(dataWB, select = -c(rois))
attach(dataWB)
models <-factor(models)
levels(models) <- c("diphone", "single", "triphone", ordered=TRUE)
detach(dataWB)

dataBroca <- filter(data_roi_phns, rois == "Broca"  & models !="semantic")
dataBroca <- subset(dataBroca, select = -c(rois))
attach(dataBroca)
models <-factor(models)
levels(models) <- c("diphone", "single", "triphone", ordered=TRUE)
detach(dataBroca)

```
## Broca's Area

First we use an overall test, lumping the count from all subjects. This is not the correct test since it does not take into account the effect of the subject.

```{r BrocaOverall, echo=FALSE}

# Overall number for each model
countBroca <- with(dataBroca, tapply(count, models, sum)) 

# Multinomial exact test overall
pvalOverall <- multinom_test(as.vector(countBroca))

# Negative Log of odds relative to the diphone model
countTotal <- sum(countBroca)
logoddS <- -log(countBroca['single']/countBroca['diphone'])
logoddT <- -log(countBroca['triphone']/countBroca['diphone'])

print(sprintf('Broca Area: Exact Multinomial Test: p=%.2g, logOdds = %.3f (S: %.3f, T: %.3f)', pvalOverall[1], mean(c(logoddS, logoddT)), logoddS, logoddT) )
```

Now we try with a mixed-effect multinomial regression

```{r BrocaMixedEffect}
# Repeat with subject as a random effect 
dataBrocaW <- reshape(dataBroca, direction="wide", v.names = c('count','performance'), timevar = 'models', idvar = 'subjects')

# Replace NAs by zeros
dataBrocaW[is.na(dataBrocaW)] <- 0

# The mixed-effect model
multinom.model.Broca <- mblogit(cbind (dataBrocaW$count.diphone,  dataBrocaW$count.single, dataBrocaW$count.triphone) ~ 1, random = ~ 1|subjects, data = dataBrocaW, method = 'PQL') 
(multinom.model.s <- summary(multinom.model.Broca)) 

# The degrees of freedom
nf <- length(multinom.model.Broca$coefficients)
dfval <-  nf + nf*(nf+1)/2

# The coefficients and their standard error
logoddS <- -multinom.model.s$coefficients[1,1]
logoddT <- -multinom.model.s$coefficients[2,1]
logoddS.se <- multinom.model.s$coefficients[1,2]
logoddT.se <- multinom.model.s$coefficients[2,2]

# Difference in deviance with the null (equal probabiliyt no subject effect)- we are going to use LR as a variable (likelihood ratio) to be consistent with r outputs
LR <- multinom.model.Broca$null.deviance-multinom.model.Broca$deviance

# The chi-square test for difference in deviances
pval <- pchisq(LR, dfval, lower.tail = FALSE )

# Printing the results
print(sprintf('Broca Area: Mixed-effect Multinomial LR with Absolute Null: Chi(%d)=%.2f, p= %.3g, logOdds = %.3f +- %.3f (S: %.3f +- %.3f, T: %.3f +- %.3f)', dfval, LR, pval, mean(c(logoddS, logoddT)), 2*sqrt((logoddS.se^2+logoddS.se^2)/4), logoddS, 2*logoddS.se, logoddT, 2*logoddT.se) )

# What is a Null deviance when one takes into consideration the random effects estimated in the actual model?

# The likelihood of such model is just the saturated model likelihood + the penalty for the random effects
# We need to compare it to the likelihood of the model + the penalty for those (smaller) random effects.

nsubjects <- nrow(dataBrocaW)
satcoeff <- array(0, dim=c(nsubjects, 2))
LModel <- 0
LS <- 0
PModel <- 0
PS <- 0
nvals <- rowSums(cbind(dataBrocaW$count.diphone,  dataBrocaW$count.single, dataBrocaW$count.triphone))

# Calculate the covariance of a saturated model
for (isubject in 1:nsubjects) {
   voxcount = sum(c(dataBrocaW$count.diphone[isubject], dataBrocaW$count.single[isubject], dataBrocaW$count.triphone[isubject]))
   p1 <- dataBrocaW$count.diphone[isubject]/voxcount
   p2 <- dataBrocaW$count.single[isubject]/voxcount
   p3 <- dataBrocaW$count.triphone[isubject]/voxcount
   if (p1 == 0 ) {
     p1 <- 0.5/voxcount
     p2 <- p2 - 0.25/voxcount
     p3 <- p3 - 0.25/voxcount
   }
    if (p2 == 0 ) {
     p2 <- 0.5/voxcount
     p1 <- p1 - 0.25/voxcount
     p3 <- p3 - 0.25/voxcount
    }
    if (p3 == 0 ) {
     p3 <- 0.5/voxcount
     p1 <- p1 - 0.25/voxcount
     p2 <- p2 - 0.25/voxcount
   }
   # print(sprintf('Subject %d: p1 = %.3f, p2 = %.3f, p3 = %.3f', isubject, p1, p2, p3))
   satcoeff[isubject, 1] <- log(p2/p1)
   satcoeff[isubject, 2] <- log(p3/p1)
}
sat.var <- cov(satcoeff)

for (isubject in 1:nsubjects) { 
  # The random effects for each subject
  rand2 <- multinom.model.Broca$linear.predictors[(isubject-1)*3+2]-multinom.model.Broca$coefficients[1]
  rand3 <- multinom.model.Broca$linear.predictors[(isubject-1)*3+3]-multinom.model.Broca$coefficients[2]
  
  # Transforming into probabilities
  k2 <- exp(multinom.model.Broca$coefficients[1]+rand2)
  k3 <- exp(multinom.model.Broca$coefficients[2]+rand3)
  p2 <- k2/(1+k2+k3)
  p3 <- k3/(1+k2+k3)
  p1 <- 1 - p2 - p3

  # Prob of the data given the model
  pmodel <-  dmultinom(c(dataBrocaW$count.diphone[isubject], dataBrocaW$count.single[isubject], dataBrocaW$count.triphone[isubject]), size = nvals[isubject], c(p1, p2, p3), log = TRUE)
  
  # Prob of the data given the saturated model
  voxcount = sum(c(dataBrocaW$count.diphone[isubject], dataBrocaW$count.single[isubject], dataBrocaW$count.triphone[isubject]))
  p1 <- dataBrocaW$count.diphone[isubject]/voxcount
  p2 <- dataBrocaW$count.single[isubject]/voxcount
  p3 <- dataBrocaW$count.triphone[isubject]/voxcount
  if (p1 == 0 ) {
     p1 <- 0.5/voxcount
     p2 <- p2 - 0.25/voxcount
     p3 <- p3 - 0.25/voxcount
  }
  if (p2 == 0 ) {
     p2 <- 0.5/voxcount
     p1 <- p1 - 0.25/voxcount
     p3 <- p3 - 0.25/voxcount
  }
  if (p3 == 0 ) {
     p3 <- 0.5/voxcount
     p1 <- p1 - 0.25/voxcount
     p2 <- p2 - 0.25/voxcount
  }
  psat <- dmultinom(c(dataBrocaW$count.diphone[isubject], dataBrocaW$count.single[isubject], dataBrocaW$count.triphone[isubject]), size = nvals[isubject], c(p1, p2, p3), log = TRUE)

  LModel <- LModel + pmodel
  LS <- LS + psat
  
  d2 <- mahalanobis(c(rand2, rand3), c(0, 0), multinom.model.Broca$VarCov[[1]]) 
  PModel <- PModel + d2
  
  d2 <- mahalanobis(c(log(p2/p1), log(p3/p1)), c(0, 0), sat.var) 
  PS <- PS + d2
  
}

# Penalty for the model
penalty.model <- nsubjects*log(2*pi*sqrt(det(multinom.model.Broca$VarCov[[1]]))) + PModel

# Penalty for the saturated model
penalty.sat <- nsubjects*log(2*pi*sqrt(det(sat.var))) + PS


LR <- 2*(LS-LModel) + penalty.sat - penalty.model
dfval <- 2
# The chi-square test for difference in deviances
pval <- pchisq(LR, dfval, lower.tail = FALSE )

# Printing the results
print(sprintf('Broca Area: Mixed-effect Multinomial LR with Random Subject Null: Chi(%d)=%.2f, p= %.3g, logOdds = %.3f +- %.3f (S: %.3f +- %.3f, T: %.3f +- %.3f)', dfval, LR, pval, mean(c(logoddS, logoddT)), 2*sqrt((logoddS.se^2+logoddS.se^2)/4), logoddS, 2*logoddS.se, logoddT, 2*logoddT.se) )
```


Now we analyze Broca's area per subject to make the table.

```{r BrocaPerSubject}
nsubjects <- nrow(dataBrocaW)
pvalSubject <- array(dim=nsubjects)
logoddSubject <- array(dim=nsubjects+2)
logoddSubjectT <- array(dim=nsubjects+2)
logoddSubjectS <- array(dim=nsubjects+2)
countPhoneme <- array(dim=nsubjects+2)

print('   Per subject:')
for (i in 1:nsubjects) {
  pval <- multinom_test(c(dataBrocaW$count.single[i],  dataBrocaW$count.diphone[i], dataBrocaW$count.triphone[i]))
  pvalSubject[i] <- as.numeric(pval[1])
  
  voxcount <- dataBrocaW$count.diphone[i] + dataBrocaW$count.single[i] + dataBrocaW$count.triphone[i]
  p1 <- dataBrocaW$count.diphone[i]/voxcount
  p2 <- dataBrocaW$count.single[i]/voxcount
  p3 <- dataBrocaW$count.triphone[i]/voxcount
  if (p1 == 0 ) {
     p1 <- 0.5/voxcount
     p2 <- p2 - 0.25/voxcount
     p3 <- p3 - 0.25/voxcount
  }
  if (p2 == 0 ) {
     p2 <- 0.5/voxcount
     p1 <- p1 - 0.25/voxcount
     p3 <- p3 - 0.25/voxcount
  }
  if (p3 == 0 ) {
     p3 <- 0.5/voxcount
     p1 <- p1 - 0.25/voxcount
     p2 <- p2 - 0.25/voxcount
  }
  logoddS <- -log(p2/p1)
  logoddT <- -log(p3/p1)
  logoddSubject[i] <- mean(c(logoddS, logoddT))
  logoddSubjectT[i] <- logoddT
  logoddSubjectS[i] <- logoddS
  countPhoneme[i]  <- dataBrocaW$count.single[i] + dataBrocaW$count.diphone[i] + dataBrocaW$count.triphone[i]
  print(sprintf('      Subject %s: p=%.2g loggOdds = %.3f (S: %.3f, T: %.3f) Count = %d',  dataBrocaW$subjects[i], pvalSubject[i], logoddSubject[i], logoddS, logoddT, countPhoneme[i]))
}


logoddSubject[12] <- mean(logoddSubject[1:nsubjects])
logoddSubject[13] <- sd(logoddSubject[1:nsubjects])/sqrt(nsubjects)

logoddSubjectS[12] <- mean(logoddSubjectS[1:nsubjects])
logoddSubjectS[13] <- sd(logoddSubjectS[1:nsubjects])/sqrt(nsubjects)

logoddSubjectT[12] <- mean(logoddSubjectT[1:nsubjects])
logoddSubjectT[13] <- sd(logoddSubjectT[1:nsubjects])/sqrt(nsubjects)

countPhoneme[12] <- mean(countPhoneme[1:nsubjects])
countPhoneme[13] <- sd(countPhoneme[1:nsubjects])/sqrt(nsubjects)

sub_label <- array(dim=nsubjects+2)
sub_label[1:11] <- 1:nsubjects
sub_label[12] <- "average"
sub_label[13] <- "sem"

```

```{r BrocaPerSubject plot generation}

subjectTable <- data.frame(subject=sub_label, l_diphone=sprintf(logoddSubject, fmt = '%#.3f') , l_single=sprintf(logoddSubjectS, fmt = '%#.3f') , l_triphone=sprintf(logoddSubjectT, fmt = '%#.3f') , count=as.integer(countPhoneme))


subjectTable %>%
  kbl(caption = "Broca's Area") %>%
  kable_classic_2(full_width = F, html_font = "Cambria")  %>%
  row_spec(4, bold = T, color = "white", background = "#FD6104")%>%
  row_spec(c(5, 6, 7, 8, 9, 10, 11), bold = T, color = "white", background = "#D7261E")%>%
  save_kable("./Fig3_sup3_BA_classic2.png")
```

## Whole Brain

This code is identical to the one above except that we are doing a chi-square test instead of a multinon_test because the sample size (the number of counts/voxels) is too large.

Single test - lumping across subjects

```{r WBOverall, echo=FALSE}

# Overall number for each model
countWB <- with(dataWB, tapply(count, models, sum)) 

# Multinomial exact test overall
gofit.res <- chisq.test(as.vector(countWB), p = c(1/3, 1/3, 1/3))

# Negative Log of odds relative to the diphone model
countTotal <- sum(countWB)
logoddS <- -log(countWB['single']/countWB['diphone'])
logoddT <- -log(countWB['triphone']/countWB['diphone'])

print(sprintf('Whole Cortex: Chi-Square Test for Goodness of Fit: Chi(%d)= %.2f p=%.2g, logOdds = %.3f (S: %.3f, T: %.3f)', gofit.res$parameter, gofit.res$statistic, gofit.res$p.value, mean(c(logoddS, logoddT)), logoddS, logoddT) )
```

```{r WBMixedEffect}
# Setting up the data to have a wide format
dataWBW <- reshape(dataWB, direction="wide", v.names = c('count','performance'), timevar = 'models', idvar = 'subjects')

# The mixed effect model
multinom.model.WB <- mblogit(cbind (dataWBW$count.diphone,  dataWBW$count.single, dataWBW$count.triphone) ~ 1, random = ~ 1|subjects, data = dataWBW) 
(multinom.model.s <- summary(multinom.model.WB)) 

# The degrees of freedom
nf <- length(multinom.model.WB$coefficients)
dfval <-  nf + nf*(nf+1)/2

# The coefficients and their standard error
logoddS <- -multinom.model.s$coefficients[1,1]
logoddT <- -multinom.model.s$coefficients[2,1]
logoddS.se <- multinom.model.s$coefficients[1,2]
logoddT.se <- multinom.model.s$coefficients[2,2]

# Difference in deviance - we are going to use LR as a variable (likelihood ratio) to be consistent with r outputs
LR <- multinom.model.WB$null.deviance-multinom.model.WB$deviance

# The chi-square test for difference in deviances
pval <- pchisq(LR, dfval, lower.tail = FALSE )

# Printing the results
print(sprintf('Whole Brain: Mixed-effect Multinomial with Absolute Null  LR: Chi(%d)=%.2f, p= %.3g, logOdds = %.3f +- %.3f (S: %.3f +- %.3f, T: %.3f +- %.3f)', dfval, LR, pval, mean(c(logoddS, logoddT)), 2*sqrt((logoddS.se^2+logoddS.se^2)/4), logoddS, 2*logoddS.se, logoddT, 2*logoddT.se) )


# Now with the Null with random effects
# The likelihood of such model is just the saturated model likelihood + the penalty for the random effects
# We need to compare it to the likelihood of the model + the penalty for those (smaller) random effects.

nsubjects <- nrow(dataWBW)
satcoeff <- array(0, dim=c(nsubjects, 2))
LModel <- 0
LS <- 0
PModel <- 0
PS <- 0
nvals <- rowSums(cbind(dataWBW$count.diphone,  dataWBW$count.single, dataWBW$count.triphone))

# Calculate the covariance of a saturated model
for (isubject in 1:nsubjects) {
   voxcount = sum(c(dataWBW$count.diphone[isubject], dataWBW$count.single[isubject], dataWBW$count.triphone[isubject]))
   p1 <- dataWBW$count.diphone[isubject]/voxcount
   p2 <- dataWBW$count.single[isubject]/voxcount
   p3 <- dataWBW$count.triphone[isubject]/voxcount
   satcoeff[isubject, 1] <- log(p2/p1)
   satcoeff[isubject, 2] <- log(p3/p1)
}
sat.var <- cov(satcoeff)

for (isubject in 1:nsubjects) { 
  # The random effects for each subject
  rand2 <- multinom.model.WB$linear.predictors[(isubject-1)*3+2]-multinom.model.WB$coefficients[1]
  rand3 <- multinom.model.WB$linear.predictors[(isubject-1)*3+3]-multinom.model.WB$coefficients[2]
  
  # Transforming into probabilities
  k2 <- exp(multinom.model.WB$coefficients[1]+rand2)
  k3 <- exp(multinom.model.WB$coefficients[2]+rand3)
  p2 <- k2/(1+k2+k3)
  p3 <- k3/(1+k2+k3)
  p1 <- 1 - p2 - p3

  # Prob of the data given the model
  pmodel <-  dmultinom(c(dataWBW$count.diphone[isubject], dataWBW$count.single[isubject], dataWBW$count.triphone[isubject]), size = nvals[isubject], c(p1, p2, p3), log = TRUE)
  
  # Prob of the data given the saturated model
  voxcount = sum(c(dataWBW$count.diphone[isubject], dataWBW$count.single[isubject], dataWBW$count.triphone[isubject]))
  p1 <- dataWBW$count.diphone[isubject]/voxcount
  p2 <- dataWBW$count.single[isubject]/voxcount
  p3 <- dataWBW$count.triphone[isubject]/voxcount
  psat <- dmultinom(c(dataWBW$count.diphone[isubject], dataWBW$count.single[isubject], dataWBW$count.triphone[isubject]), size = nvals[isubject], c(p1, p2, p3), log = TRUE)

  LModel <- LModel + pmodel
  LS <- LS + psat
  
  d2 <- mahalanobis(c(rand2, rand3), c(0, 0), multinom.model.WB$VarCov[[1]]) 
  PModel <- PModel + d2
  
  d2 <- mahalanobis(c(log(p2/p1), log(p3/p1)), c(0, 0), sat.var) 
  PS <- PS + d2
  
}

# Penalty for the model
penalty.model <- nsubjects*log(2*pi*sqrt(det(multinom.model.WB$VarCov[[1]]))) + PModel

# Penalty for the saturated model
penalty.sat <- nsubjects*log(2*pi*sqrt(det(sat.var))) + PS


LR <- 2*(LS-LModel) + penalty.sat - penalty.model
dfval <- 2
# The chi-square test for difference in deviances
pval <- pchisq(LR, dfval, lower.tail = FALSE )

# Printing the results
print(sprintf('Whole Cortex: Mixed-effect Multinomial LR with Random Subject Null: Chi(%d)=%.2f, p= %.3g, logOdds = %.3f +- %.3f (S: %.3f +- %.3f, T: %.3f +- %.3f)', dfval, LR, pval, mean(c(logoddS, logoddT)), 2.0*sqrt((logoddS.se^2+logoddS.se^2)/4), logoddS, 2.0*logoddS.se, logoddT, 2.0*logoddT.se) )      
```


```{r WBPerSubject}

# Repeat per subject

nsubjects <- nrow(dataWBW)
pvalSubject <- array(dim=nsubjects)
logoddSubject <- array(dim=nsubjects+2)
logoddSubjectT <- array(dim=nsubjects+2)
logoddSubjectS <- array(dim=nsubjects+2)
countPhoneme <- array(dim=nsubjects+2)

print('   Per subject:')
for (i in 1:nsubjects) {
  gofit.res <- chisq.test(c(dataWBW$count.single[i],  dataWBW$count.diphone[i], dataWBW$count.triphone[i]), p = c(1/3, 1/3, 1/3))
  pvalSubject[i] <- gofit.res$p.value
  logoddS <- -log(dataWBW$count.single[i]/dataWBW$count.diphone[i])
  logoddT <- -log(dataWBW$count.triphone[i]/dataWBW$count.diphone[i])
  logoddSubject[i] <- mean(c(logoddS, logoddT))
  logoddSubjectT[i] <- logoddT
  logoddSubjectS[i] <- logoddS
  countPhoneme[i]  <- dataWBW$count.single[i] + dataWBW$count.diphone[i] + dataWBW$count.triphone[i]
  print(sprintf('      Subject %s: Chi(%d)= %.2f p=%.2g loggOdds = %.3f (S: %.3f, T: %.3f) Count = %d',  dataWBW$subjects[i], gofit.res$parameter, gofit.res$statistic, pvalSubject[i], logoddSubject[i], logoddS, logoddT, countPhoneme[i]))
}

logoddSubject[12] <- mean(logoddSubject[1:nsubjects])
logoddSubject[13] <- sd(logoddSubject[1:nsubjects])/sqrt(nsubjects)

logoddSubjectS[12] <- mean(logoddSubjectS[1:nsubjects])
logoddSubjectS[13] <- sd(logoddSubjectS[1:nsubjects])/sqrt(nsubjects)

logoddSubjectT[12] <- mean(logoddSubjectT[1:nsubjects])
logoddSubjectT[13] <- sd(logoddSubjectT[1:nsubjects])/sqrt(nsubjects)

countPhoneme[12] <- mean(countPhoneme[1:nsubjects])
countPhoneme[13] <- sd(countPhoneme[1:nsubjects])/sqrt(nsubjects)

sub_label <- array(dim=nsubjects+2)
sub_label[1:11] <- 1:nsubjects
sub_label[12] <- "average"
sub_label[13] <- "sem"


```

```{r WBPerSubject plot generation}

subjectTable <- data.frame(subject=sub_label, l_diphone=sprintf(logoddSubject, fmt = '%#.3f') , l_single=sprintf(logoddSubjectS, fmt = '%#.3f') , l_triphone=sprintf(logoddSubjectT, fmt = '%#.3f') , count=countPhoneme)


subjectTable %>%
  kbl(caption = "Cerebral Cortex") %>%
  kable_classic_2(full_width = F, html_font = "Cambria")  %>%
  row_spec(1:11, bold = T, color = "white", background = "#D7261E")%>%

  save_kable("./Fig3_sup3_WB_classic2.png")
```

## Temporal Cortex

For the temporal cortex, we are also doing a chi-sauare test instead of a multinon_test because of the large number of voxels. We first test for the main effect and therefore collapse across subareas.

```{r TCOverall, echo=FALSE}

dataLCW <- reshape(dataLC, direction="wide", v.names = c('count','performance'), timevar = 'models', idvar = c('subjects', 'rois'))

dataLCW.agg <- aggregate(cbind(count.single, count.diphone, count.triphone) ~ subjects, data= dataLCW, sum)

# Overall number for each model
countLC <- with(dataLCW.agg,c(sum(count.single), sum(count.diphone), sum(count.triphone))) 

# Multinomial exact test overall
gofit.res <- chisq.test(countLC, p = c(1/3, 1/3, 1/3))

# Negative Log of odds relative to the diphone model
countTotal <- sum(countLC)
logoddS <- -log(countLC[1]/countLC[2])
logoddT <- -log(countLC[3]/countLC[2])

print(sprintf('Temporal Cortex: Chi-Square Test for Goodness of Fit: Chi(%d)= %.2f p=%.2g, logOdds = %.3f (S: %.3f, T: %.3f)', gofit.res$parameter, gofit.res$statistic, gofit.res$p.value, mean(c(logoddS, logoddT)), logoddS, logoddT) )
```

## LT Bar plot to examine interaction

```{r LTbarpot, echo=FALSE}
bxp <-
  ggboxplot(
    dataLC, x = "rois", y = "count",
    color = "models", color_order = c("single", "diphone", "triphone"),
    palette = "jco")
bxp

```

## LT Interaction between roi and model for the temporal cortex

We perform a multinomial regression to model the interaction between the models and the rois.

```{r LTInteraction, echo=FALSE}

# The full mixed effect model with interaction
multinom.model.LC.int <- mblogit(cbind (dataLCW$count.diphone,  dataLCW$count.single, dataLCW$count.triphone) ~ rois, random = ~ 1|subjects, data = dataLCW) 
(multinom.model.s <- summary(multinom.model.LC.int)) 

# The degrees of freedom
nf <- length(multinom.model.LC.int$coefficients)
dfval <-  nf + 3

# The nested model
multinom.model.LC.noint <- mblogit(cbind (dataLCW$count.diphone,  dataLCW$count.single, dataLCW$count.triphone) ~ 1, random = ~ 1|subjects, data = dataLCW)

lr.res <- anova(multinom.model.LC.noint, multinom.model.LC.int, test='Chisq')

# Printing the results
print(sprintf('Temporal Cortex Roi interaction: Mixed-effect Multinomial LR with Random Subject Null: Chi(%d)=%.2f, p= %.3g', lr.res$Df[2], lr.res$Deviance[2], lr.res$`Pr(>Chi)`[2]))
      
# The coefficients and their standard error for AC
logoddS <- -multinom.model.s$coefficients[1,1]
logoddT <- -multinom.model.s$coefficients[2,1]
logoddS.se <- multinom.model.s$coefficients[1,2]
logoddT.se <- multinom.model.s$coefficients[2,2]

print(sprintf('Temporal Cortex AC: logOdds = %.3f +- %.3f (S: %.3f +- %.3f, T: %.3f +- %.3f)', mean(c(logoddS, logoddT)), 2*sqrt((logoddS.se^2+logoddS.se^2)/4), logoddS, 2*logoddS.se, logoddT, 2*logoddT.se) )

# The coefficients and their standard error for STG
logoddS <- -multinom.model.s$coefficients[1,1] - multinom.model.s$coefficients[5,1] 
logoddT <- -multinom.model.s$coefficients[2,1]- multinom.model.s$coefficients[6,1] 
logoddS.se <- multinom.model.s$coefficients[5,2]
logoddT.se <- multinom.model.s$coefficients[6,2]

print(sprintf('Temporal Cortex STG: logOdds = %.3f +- %.3f (S: %.3f +- %.3f, T: %.3f +- %.3f)', mean(c(logoddS, logoddT)), 2*sqrt((logoddS.se^2+logoddS.se^2)/4), logoddS, 2*logoddS.se, logoddT, 2*logoddT.se) )

# The coefficients and their standard error for STS
logoddS <- -multinom.model.s$coefficients[1,1] - multinom.model.s$coefficients[7,1] 
logoddT <- -multinom.model.s$coefficients[2,1]- multinom.model.s$coefficients[8,1] 
logoddS.se <- multinom.model.s$coefficients[7,2]
logoddT.se <- multinom.model.s$coefficients[8,2]

print(sprintf('Temporal Cortex STS: logOdds = %.3f +- %.3f (S: %.3f +- %.3f, T: %.3f +- %.3f)', mean(c(logoddS, logoddT)), 2*sqrt((logoddS.se^2+logoddS.se^2)/4), logoddS, 2*logoddS.se, logoddT, 2*logoddT.se) )

# The coefficients and their standard error for LTC
logoddS <- -multinom.model.s$coefficients[1,1] - multinom.model.s$coefficients[3,1] 
logoddT <- -multinom.model.s$coefficients[2,1]- multinom.model.s$coefficients[4,1] 
logoddS.se <- multinom.model.s$coefficients[3,2]
logoddT.se <- multinom.model.s$coefficients[4,2]

print(sprintf('Temporal Cortex LTC:  logOdds = %.3f +- %.3f (S: %.3f +- %.3f, T: %.3f +- %.3f)', mean(c(logoddS, logoddT)), 2*sqrt((logoddS.se^2+logoddS.se^2)/4), logoddS, 2*logoddS.se, logoddT, 2*logoddT.se) )



# Is this the same as a contigency table test with chisquare?
# It it very similar but the mixed effect multinomial logistic regression deals with the multiple subjects
count.diphone.all <- with(dataLCW, tapply(count.diphone, rois, sum))
count.single.all <- with(dataLCW, tapply(count.single, rois, sum))
count.triphone.all <- with(dataLCW, tapply(count.triphone, rois, sum))
x <- matrix( data = c(count.diphone.all, count.single.all, count.triphone.all), nrow=3, ncol=4, byrow=TRUE)

(cont.res <- chisq.test(x))

```



```{r LTInteractionPerSubject, echo=FALSE}
# Finally, perform this analysis per subject
subject.names <- unique(dataLCW$subjects)

nsubjects <- length(subject.names)
pvalSubject <- array(dim=nsubjects)
logoddSubject <- array(dim=c(nsubjects+2,4))
logoddSSubject <- array(dim=c(nsubjects+2,4))
logoddTSubject <- array(dim=c(nsubjects+2,4))
countPhoneme <- array(dim=c(nsubjects+2,4))

i <- 1
for (sname in subject.names) {
  data.subject <- dataLCW[dataLCW$subjects==sname,]
  (subject.res <- chisq.test(cbind(data.subject$count.single, data.subject$count.diphone, data.subject$count.triphone )))
    logoddSSubject[i,] <- -log(data.subject$count.single/data.subject$count.diphone)
    logoddTSubject[i,] <-  -log(data.subject$count.triphone/data.subject$count.diphone)
  logoddSubject[i,] <-  -0.5*(log(data.subject$count.single/data.subject$count.diphone) + log(data.subject$count.triphone/data.subject$count.diphone))
  countPhoneme[i,] <- data.subject$count.single+data.subject$count.diphone+data.subject$count.triphone
  pvalSubject[i] <- subject.res$p.value
  
  print(sprintf('Subject %s Chisq(%d) = %.3f p = %.3g', sname, subject.res$parameter, subject.res$statistic, subject.res$p.value))
  print(sprintf('    AC  l=%.3f (S:%.3f, T:%.3f)', logoddSubject[i,1], logoddSSubject[i,1], logoddTSubject[i,1]))
  print(sprintf('    STG l=%.3f (S:%.3f, T:%.3f)', logoddSubject[i,2], logoddSSubject[i,2], logoddTSubject[i,2]))
  print(sprintf('    STS l=%.3f (S:%.3f, T:%.3f)', logoddSubject[i,3], logoddSSubject[i,3], logoddTSubject[i,3]))
  print(sprintf('    LTC l=%.3f (S:%.3f, T:%.3f)', logoddSubject[i,4], logoddSSubject[i,4], logoddTSubject[i,4]))
  if (data.subject$rois[1] != 'ACunique' | data.subject$rois[2] != 'STG' | data.subject$rois[3] != 'STS' | data.subject$rois[4] != 'LTCunique' ) {
    print('Error - order of rois not respected' )
  }
  i <- i + 1
}

logoddSubject[12,] <- colMeans(logoddSubject[1:nsubjects,])
logoddSubject[13,] <- GMCM:::colSds(logoddSubject[1:nsubjects,])/sqrt(nsubjects)

logoddSSubject[12,] <- colMeans(logoddSSubject[1:nsubjects,])
logoddSSubject[13,] <- GMCM:::colSds(logoddSSubject[1:nsubjects,])/sqrt(nsubjects)

logoddTSubject[12,] <- colMeans(logoddTSubject[1:nsubjects,])
logoddTSubject[13,] <- GMCM:::colSds(logoddTSubject[1:nsubjects,])/sqrt(nsubjects)

countPhoneme[12,] <- colMeans(countPhoneme[1:nsubjects,])
countPhoneme[13,] <- GMCM:::colSds(countPhoneme[1:nsubjects,])/sqrt(nsubjects)

sub_label <- array(dim=nsubjects+2)
sub_label[1:11] <- 1:nsubjects
sub_label[12] <- "average"
sub_label[13] <- "sem"

# logoddSubject <- sprintf(logoddSubject, fmt = '%#.3f')
# logoddSSubject <- sprintf(logoddSSubject, fmt = '%#.3f')
# logoddTSubject <- sprintf(logoddTSubject, fmt = '%#.3f')

subjectTable <- data.frame(subject=sub_label, 
                           AClavg=sprintf(logoddSubject[,1], fmt = '%#.3f'), AClsin=sprintf(logoddSSubject[,1], fmt = '%#.3f'),
                           ACltri=sprintf(logoddTSubject[,1], fmt = '%#.3f'), cAC=countPhoneme[,1], 
                           STGlavg=sprintf(logoddSubject[,2], fmt = '%#.3f'), STGlsin=sprintf(logoddSSubject[,2], fmt = '%#.3f'),
                           STGltri=sprintf(logoddTSubject[,2], fmt = '%#.3f'), cSTG=countPhoneme[,2], 
                           STSlavg=sprintf(logoddSubject[,3], fmt = '%#.3f'), STSlsin=sprintf(logoddSSubject[,3], fmt = '%#.3f'),
                           STSltri=sprintf(logoddTSubject[,3], fmt = '%#.3f'), cSTS=countPhoneme[,3],
                           LTClavg=sprintf(logoddSubject[,4], fmt = '%#.3f'), LTClsin=sprintf(logoddSSubject[,4], fmt = '%#.3f'),
                           LTCltri=sprintf(logoddTSubject[,4], fmt = '%#.3f'), cLTC=countPhoneme[,4]
                           )


```
## TC subareas quickly check for each subject for each ROI the differences between single, diphone and triphones

```{r TC subareas}

TC_subareas = c("ACunique", "STG", "STS", "LTCunique")
for (r in TC_subareas){
  print(r)
  dataTC_sub <- filter(data_roi_phns, rois == r)
  attach(dataTC_sub)
  models <-factor(models)
  levels(models) <- c("diphone", "single", "triphone", ordered=TRUE)
  detach(dataTC_sub)
  
  dataTC_subW <- reshape(dataTC_sub, direction="wide", v.names = c('count','performance'), timevar = 'models', idvar = 'subjects')
  dataTC_subW[is.na(dataTC_subW)] <- 0
  
  print('   Per subject:')
  for (i in 1:nsubjects) {
    gofit.res <- chisq.test(c(dataTC_subW$count.single[i],  dataTC_subW$count.diphone[i], dataTC_subW$count.triphone[i]), p = c(1/3, 1/3, 1/3))
    pvalSubject <- gofit.res$p.value
    logoddS <- -log(dataTC_subW$count.single[i]/dataTC_subW$count.diphone[i])
    logoddT <- -log(dataTC_subW$count.triphone[i]/dataTC_subW$count.diphone[i])
    logoddSubject <- mean(c(logoddS, logoddT))
    logoddSubjectT <- logoddT
    logoddSubjectS<- logoddS
    countPhoneme  <- dataTC_subW$count.single[i] + dataTC_subW$count.diphone[i] + dataTC_subW$count.triphone[i]
    print(sprintf('      Subject %s: Chi(%d)= %.2f p=%.2g (manual adjusted p=%.2g) loggOdds = %.3f (S: %.3f, T: %.3f) Count = %d',  dataTC_subW$subjects[i], gofit.res$parameter, gofit.res$statistic, pvalSubject,pvalSubject*nsubjects, logoddSubject, logoddS, logoddT, dataTC_subW$count.single[i] + dataTC_subW$count.diphone[i] + dataTC_subW$count.triphone[i]))
  }
}






```

```{r prep for plot}


## PAC
AC_idx <- c(3,5,6,7,9, 11)
AC_color <- c("#FEF001", "#D7261E", "#FD6104", "#D7261E","#FEF001", "#D7261E")
AC_headers <- c("AClavg", "AClsin", "ACltri", "cAC")

for (i in 1:length(AC_idx)) {
  for (h in AC_headers){
    if (h == "cAC"){
       subjectTable[h][[1]][AC_idx[i]] <- cell_spec(as.integer(subjectTable[h][[1]][AC_idx[i]]),  color = "white", background=AC_color[i], escape = F)
    }
    else{
       subjectTable[h][[1]][AC_idx[i]] <- cell_spec(sprintf(as.numeric(subjectTable[h][[1]][AC_idx[i]]), fmt = '%#.3f'),  color = "white", background=AC_color[i], escape = F)
    }
   
  }
}

AC_tmp_idx <- c(1,2,4,8,10,12,13)
for (i in 1:length(AC_tmp_idx)) {
  for (h in AC_headers){
    if (h == "cAC"){
      subjectTable[h][[1]][AC_tmp_idx[i]] <- cell_spec(as.integer(subjectTable[h][[1]][AC_tmp_idx[i]]),  color = "black", escape = F)
    }
    else{
      subjectTable[h][[1]][AC_tmp_idx[i]] <- cell_spec(sprintf(as.numeric(subjectTable[h][[1]][AC_tmp_idx[i]]), fmt = '%#.3f'),  color = "black", escape = F)
    }
  }
}

## STG
STG_idx <- c(1, 4, 5, 6, 7, 8, 9, 11)
STG_color <- c("#D7261E", "#D7261E", "#FD6104", "#FD6104","#D7261E","#FD6104","#D7261E","#D7261E")
STG_headers <- c("STGlavg", "STGlsin", "STGltri", "cSTG")
for (i in 1:length(STG_idx)) {
  for (h in STG_headers){
    if (h == "cSTG"){
      subjectTable[h][[1]][STG_idx[i]] <- cell_spec(as.integer(subjectTable[h][[1]][STG_idx[i]]),  color = "white", background=STG_color[i], escape = F)
    }
    else{
      subjectTable[h][[1]][STG_idx[i]] <- cell_spec(sprintf(as.numeric(subjectTable[h][[1]][STG_idx[i]]), fmt = '%#.3f'),  color = "white", background=STG_color[i], escape = F)
    }
  }
}

STG_tmp_idx <- c(2,3,10,12,13)
for (i in 1:length(STG_tmp_idx)) {
  for (h in STG_headers){
    if (h == "cSTG"){
      subjectTable[h][[1]][STG_tmp_idx[i]] <- cell_spec(as.integer(subjectTable[h][[1]][STG_tmp_idx[i]]),  color = "black", escape = F)
    }
    else{
      subjectTable[h][[1]][STG_tmp_idx[i]] <- cell_spec(sprintf(as.numeric(subjectTable[h][[1]][STG_tmp_idx[i]]), fmt = '%#.3f'),  color = "black", escape = F)
    }
  }
}

## STS
STS_idx <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
STS_color <- c("#D7261E", "#D7261E", "#D7261E", "FEF001","#D7261E","#D7261E","#D7261E", "#D7261E", "#D7261E", "#D7261E","#D7261E")
STS_headers <- c("STSlavg", "STSlsin", "STSltri", "cSTS")
for (i in 1:length(STS_idx)) {
  for (h in STS_headers){
    if (h == "cSTS"){
      subjectTable[h][[1]][STS_idx[i]] <- cell_spec(as.integer(subjectTable[h][[1]][STS_idx[i]]),  color = "white", background=STS_color[i], escape = F)
    }
    else{
      subjectTable[h][[1]][STS_idx[i]] <- cell_spec(sprintf(as.numeric(subjectTable[h][[1]][STS_idx[i]]), fmt = '%#.3f'),  color = "white", background=STS_color[i], escape = F)
    }
  }
}

STS_tmp_idx <- c(12, 13)
for (i in 1:length(STS_tmp_idx)) {
  for (h in STS_headers){
    if (h == "cSTS"){
      subjectTable[h][[1]][STS_tmp_idx[i]] <- cell_spec(as.integer(subjectTable[h][[1]][STS_tmp_idx[i]]),  color = "black", escape = F)
    }
    else{
      subjectTable[h][[1]][STS_tmp_idx[i]] <- cell_spec(sprintf(as.numeric(subjectTable[h][[1]][STS_tmp_idx[i]]), fmt = '%#.3f'),  color = "black", escape = F)
    }
  }
}

## LTC
LTC_idx <- c(2, 4, 5,8, 9, 11)
LTC_color <- c("#D7261E", "#FD6104", "#D7261E", "#FEF001","#D7261E","#D7261E")
LTC_headers <- c("LTClavg", "LTClsin", "LTCltri", "cLTC")
for (i in 1:length(LTC_idx)) {
  for (h in LTC_headers){
    if (h == "cLTC"){
      subjectTable[h][[1]][LTC_idx[i]] <- cell_spec(as.integer(subjectTable[h][[1]][LTC_idx[i]]),  color = "white", background=LTC_color[i], escape = F)
    }
    else{
      subjectTable[h][[1]][LTC_idx[i]] <- cell_spec(sprintf(as.numeric(subjectTable[h][[1]][LTC_idx[i]]), fmt = '%#.3f'),  color = "white", background=LTC_color[i], escape = F)
    }
  }
}

LTC_tmp_idx <- c(1, 3,6,7, 10,  12, 13)
for (i in 1:length(LTC_tmp_idx)) {
  for (h in LTC_headers){
    if (h == "cLTC"){
      subjectTable[h][[1]][LTC_tmp_idx[i]] <- cell_spec(as.integer(subjectTable[h][[1]][LTC_tmp_idx[i]], fmt = '%#.3f'),  color = "black", escape = F)
    }
    else{
      subjectTable[h][[1]][LTC_tmp_idx[i]] <- cell_spec(sprintf(as.numeric(subjectTable[h][[1]][LTC_tmp_idx[i]]), fmt = '%#.3f'),  color = "black", escape = F)
    }
  }
}

```

```{r TC subarea  plot generation}

subjectTable %>%
  kbl(caption = "Temporal Cortex",
      col.names = c("subject", "l_single","l_diphone","l_triphone","count",
                    "l_single","l_diphone","l_triphone","count",
                    "l_single","l_diphone","l_triphone","count",
                    "l_single","l_diphone","l_triphone","count")) %>%
  kable_classic_2(full_width = F, html_font = "Cambria",)  %>%
  add_header_above(c(" " = 1, "PAC" = 4, "STG" = 4, 
                     "STS" = 4, "LTC" = 4)) %>%
  # row_spec(c(1,4,5,6,7,8,9,10,11), bold = T, color = "white", background = "#D7261E")%>%
  save_kable("./Fig3_sup3_TC_classic2.png")
```
